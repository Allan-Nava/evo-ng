package ng

import (
	"github.com/getevo/evo-ng"
	"github.com/getevo/evo-ng/internal/file"
	"github.com/moznion/gowrtr/generator"
	"strings"
	"time"
)

type Skeleton struct {
	App       string            `json:"app"`
	Version   Version           `json:"version"`
	Include   []string          `json:"include"`
	HotReload bool              `json:"hot_reload"`
	Debug     bool              `json:"debug"`
	Config    []string          `json:"config"`
	Replace   map[string]string `json:"replace"`
	Module    string            `json:"module"`
	Packages  map[string]*Package
}

func (s *Skeleton) GenContext() {
	var root = generator.NewRoot()
	var imports = []string{"github.com/getevo/evo-ng"}
	var context = generator.NewStruct("Context")
	context = context.AddField("Base", "*evo.Context")
	context = context.AddField("fiber", "*fiber.Ctx")
	var statements = []generator.Statement{
		generator.NewRawStatement("c.Base = request"),
		generator.NewRawStatement("c.fiber = request.Fiber()"),
	}
	for _, include := range skeleton.Include {
		var pkg = skeleton.GetPackage(include)
		var imp = false
		for _, comment := range pkg.Comments {
			var fields = strings.Fields(comment)
			if len(fields) == 4 && strings.ToLower(fields[1]) == "extend" && strings.ToLower(fields[3]) == "context" {
				for _, decl := range pkg.Structs {
					if decl.HasFunction(ContextInterface) {
						context = context.AddField(fields[2], pkg.Name+"."+decl.Name)
						imp = true
						statements = append(statements, generator.NewRawStatement("c."+fields[2]+".Extend()"))
						//decl.Name+".Extend(request)",
					}
				}
			}
		}
		if imp {
			if pkg.IsLocal {
				imports = append(imports, skeleton.Module+"/"+include)
			} else {
				imports = append(imports, strings.Split(include, "@")[0])
			}
		}

	}
	imports = append(imports, "github.com/gofiber/fiber/v2")

	root = root.AddStatements(
		generator.NewPackage("request"),
		generator.NewComment("GENERATED BY EVO-NG"),
		generator.NewImport(imports...),
		generator.NewNewline(),
		generator.NewComment("Context struct represents the Context which hold the HTTP request and response. It has methods and variables for the request query string, parameters, body, HTTP headers, and so on which can also extends."),
		context,
	)

	statements = append(statements, generator.NewReturnStatement("callback.(func(*Context) error)(c)"))

	root = root.AddStatements(generator.NewNewline(),
		generator.NewCommentf("New create new type of struct"),
		generator.NewFunc(
			generator.NewFuncReceiver("c", "*Context"),
			generator.NewFuncSignature("New").AddReturnTypes("evo.ContextInterface"),
			generator.NewReturnStatement("&Context{}"),
		))
	for _, method := range []string{"Get", "Post", "All", "Put", "Push", "Options", "Delete"} {
		root = root.AddStatements(
			generator.NewNewline(),
			generator.NewCommentf("%s Wrap context http %s requests. callback accepts func(*request.Context)", method, method),
			generator.NewFunc(
				generator.NewFuncReceiver("c", "*Context"),
				generator.NewFuncSignature(method).AddParameters(
					generator.NewFuncParameter("request ", "*evo.Context"),
					generator.NewFuncParameter("callback", "interface{}"),
				).AddReturnTypes("err error"),

				statements...,
			),

			generator.NewNewline(),
			generator.NewCommentf("%s Matches http %s requests. callback accepts func(*request.Context)", method, method),
			generator.NewFunc(
				nil,
				generator.NewFuncSignature(method).AddParameters(
					generator.NewFuncParameter("url ", "string"),
					generator.NewFuncParameter("callback", "func(*Context) error"),
					generator.NewFuncParameter("params...", "interface{}"),
				),
				generator.NewRawStatement("evo."+method+("(url,callback,params...)")),
			),
		)

	}

	generated, err := root.Generate(0)
	if err != nil {
		evo.Panic(err)
	}

	file.MakePath(file.WorkingDir() + "/request")
	file.Write(file.WorkingDir()+"/request/context.go", generated)

	if !file.IsFileExist(file.WorkingDir() + "/request/context.extend.go") {
		file.Write(file.WorkingDir()+"/request/context.extend.go", "package request \r\n//Project Extended Context\r\n")
	}

	b, err := file.ReadFile(file.WorkingDir() + "/vendor/github.com/getevo/evo-ng/context.go")
	if err != nil {
		evo.Panic(err)
	}
	file.Write(file.WorkingDir()+"/request/context.fn.go", strings.Replace(string(b), "package evo", "package request", 1))
}

func (s *Skeleton) GetPackage(path string) *Package {
	if _, ok := s.Packages[path]; !ok {
		s.Packages[path] = ParsePackage(path)
	}
	return s.Packages[path]

}

type Version struct {
	Auto  bool      `json:"auto"`
	Major int       `json:"major"`
	Minor int       `json:"minor"`
	Date  time.Time `json:"date"`
}

type Include struct {
	Repo   *string `json:"repo,omitempty"`
	Branch *string `json:"branch,omitempty"`
	Local  *string `json:"local,omitempty"`
}

type Main struct {
	Root             *generator.Root
	ContextInterface Function
	Main             *generator.Func
}
