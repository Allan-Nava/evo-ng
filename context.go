package evo

//DO NOT EDIT THIS FILE

import (
	"encoding/json"
	"fmt"
	"github.com/getevo/evo/lib/log"
	"github.com/gofiber/fiber/v2"
	"github.com/valyala/fasthttp"
	"io"
	"mime/multipart"
	"strings"
	"time"
)

// Cookie container wrapper struct
type Cookie fiber.Cookie

// Response to be done
type Response struct {
}

// Cookie is used for getting a cookie value by key.
// value accepts string,int,int64,int8,int32,int16,uint,uint64,uint8,uint16,uint32,float32,float64,complex64,complex128 as value of cookie
// value accepts struct and turn it into json string as value of cookie
// value accepts time.Time,time.Duration as expiration time of cookie
// value accepts fiber.Cookie,request.Cookie as custom cookie settings
// Make copies or use the Immutable setting to use the value outside the Handler.
func (ctx *Context) Cookie(key string, value ...interface{}) string {
	if len(value) > 0 {
		var cookie = fiber.Cookie{}
		for _, item := range value {
			switch val := item.(type) {
			case Cookie:
				cookie = fiber.Cookie(val)
			case *Cookie:
				cookie = fiber.Cookie(*val)
			case fiber.Cookie:
				cookie = val
			case *fiber.Cookie:
				cookie = *val
			case time.Duration:
				cookie.Expires = time.Now().Add(val)
			case time.Time:
				cookie.Expires = val
			case string:
				cookie.Value = val
			case int, int64, int8, int32, int16, uint, uint64, uint8, uint16, uint32, float32, float64, complex64, complex128:
				cookie.Value = fmt.Sprint(val)
			default:
				var b, err = json.Marshal(value)
				if err != nil {
					log.Error(err)
				} else {
					cookie.Value = string(b)
				}

			}
		}
		cookie.Name = key
		ctx.fiber.Cookie(&cookie)
	}
	return ctx.fiber.Cookies(key)
}

// Header set/get the HTTP request header specified by field and value.
// Field names are case-insensitive
// value will be join by semicolon in case of more than one
// Returned value is only valid within the handler. Do not store any references.
// Make copies or use the Immutable setting instead.
func (ctx *Context) Header(key string, value ...string) string {
	if len(value) > 0 {
		ctx.fiber.Set(key, strings.Join(value, ";"))
	}
	return ctx.fiber.Get(key)
}

// Status sets the HTTP status for the response.
// This method is chainable.
func (ctx *Context) Status(status int) *Context {
	ctx.fiber.Status(status)
	return ctx
}

// Query returns the query string parameter in the url.
// Defaults to empty string "" if the query doesn't exist.
// If a default value is given, it will return that value if the query doesn't exist.
// Returned value is only valid within the handler. Do not store any references.
// Make copies or use the Immutable setting to use the value outside the Handler.
func (ctx *Context) Query(key string, defaultValue ...string) string {
	return ctx.fiber.Query(key, defaultValue...)
}

// Protocol contains the request protocol string: http or https for TLS requests.
func (ctx *Context) Protocol() string {
	return ctx.fiber.Protocol()
}

// Hostname contains the hostname derived from the Host HTTP header.
// Returned value is only valid within the handler. Do not store any references.
// Make copies or use the Immutable setting instead.
func (c *Context) Hostname() string {
	return c.fiber.Hostname()
}

// IPs returns an string slice of IP addresses specified in the X-Forwarded-For request header.
func (c *Context) IPs() (ips []string) {
	return c.fiber.IPs()
}

// Is returns the matching content type,
// if the incoming request's Content-Type HTTP header field matches the MIME type specified by the type parameter
func (c *Context) Is(extension string) bool {
	return c.fiber.Is(extension)
}

// Locals makes it possible to pass interface{} values under string keys scoped to the request
// and therefore available to all following routes that match the request.
func (c *Context) Locals(key string, value ...interface{}) (val interface{}) {
	return c.fiber.Locals(key, value...)
}

// Location sets the response Location HTTP header to the specified path parameter.
func (c *Context) Location(path string) {
	c.fiber.Location(path)
}

// Redirect to the URL derived from the specified path, with specified status.
// If status is not specified, status defaults to 302 Found.
func (c *Context) Redirect(location string, status ...int) {
	c.fiber.Redirect(location, status...)
}

// Method contains a string corresponding to the HTTP method of the request: GET, POST, PUT and so on.
func (c *Context) Method(override ...string) string {
	return c.fiber.Method()
}

// Subdomains returns a string slice of subdomains in the domain name of the request.
// The subdomain offset, which defaults to 2, is used for determining the beginning of the subdomain segments.
func (c *Context) Subdomains(offset ...int) []string {
	o := 2
	if len(offset) > 0 {
		o = offset[0]
	}
	subdomains := strings.Split(c.Hostname(), ".")
	l := len(subdomains) - o
	// Check index to avoid slice bounds out of range panic
	if l < 0 {
		l = len(subdomains)
	}
	subdomains = subdomains[:l]
	return subdomains
}

// String returns unique string representation of the ctx.
//
// The returned value may be useful for logging.
func (c *Context) String() string {
	return c.fiber.String()
}

// Vary adds the given header field to the Vary response header.
// This will append the header, if not already listed, otherwise leaves it listed in the current location.
func (c *Context) Vary(fields ...string) {
	c.fiber.Vary(fields...)
}

// Accepts checks if the specified extensions or content types are acceptable.
func (c *Context) Accepts(offers ...string) string {
	return c.fiber.Accepts(offers...)
}

// AcceptsCharsets checks if the specified charset is acceptable.
func (c *Context) AcceptsCharsets(offers ...string) string {
	return c.fiber.AcceptsCharsets(offers...)
}

// AcceptsEncodings checks if the specified encoding is acceptable.
func (c *Context) AcceptsEncodings(offers ...string) string {
	return c.fiber.AcceptsEncodings(offers...)
}

// AcceptsLanguages checks if the specified language is acceptable.
func (c *Context) AcceptsLanguages(offers ...string) string {
	return c.fiber.AcceptsLanguages(offers...)
}

// ClearCookie expires a specific cookie by key on the client side.
// If no key is provided it expires all cookies that came with the request.
func (c *Context) ClearCookie(key ...string) {
	c.fiber.ClearCookie(key...)
}

// Download transfers the file from path as an attachment.
// Typically, browsers will prompt the user for download.
// By default, the Content-Disposition header filename= parameter is the filepath (this typically appears in the browser dialog).
// Override this default with the filename parameter.
func (c *Context) Download(file string, filename ...string) error {
	return c.fiber.Download(file, filename...)
}

func (c *Context) Fresh() bool {
	return c.fiber.Fresh()
}

// Request return the *fasthttp.Request object
// This allows you to use all fasthttp request methods
// https://godoc.org/github.com/valyala/fasthttp#Request
func (c *Context) Request() *fasthttp.Request {
	return c.fiber.Request()
}

// Response return the *fasthttp.Response object
// This allows you to use all fasthttp response methods
// https://godoc.org/github.com/valyala/fasthttp#Response
func (c *Context) Response() *fasthttp.Response {
	return c.fiber.Response()
}

// Format performs content-negotiation on the Accept HTTP header.
// It uses Accepts to select a proper format.
// If the header is not specified or there is no proper format, text/plain is used.
func (c *Context) Format(body interface{}) error {
	return c.fiber.Format(body)
}

// FormFile returns the first file by key from a MultipartForm.
func (c *Context) FormFile(key string) (*multipart.FileHeader, error) {
	return c.fiber.FormFile(key)
}

// FastHTTP returns *fasthttp.RequestCtx that carries a deadline
// a cancellation signal, and other values across API boundaries.
func (c *Context) FastHTTP() *fasthttp.RequestCtx {
	return c.fiber.Context()
}

// XHR returns a Boolean property, that is true, if the request's X-Requested-With header field is XMLHttpRequest,
// indicating that the request was issued by a client library (such as jQuery).
func (c *Context) XHR() bool {
	return c.fiber.XHR()
}

// Route returns the matched Route struct.
func (c *Context) Route() *fiber.Route {
	return c.fiber.Route()
}

// SaveFile saves any multipart file to disk.
func (c *Context) SaveFile(fileheader *multipart.FileHeader, path string) error {
	return fasthttp.SaveMultipartFile(fileheader, path)
}

// Secure returns a boolean property, that is true, if a TLS connection is established.
func (c *Context) Secure() bool {
	return c.fiber.Secure()
}

// WriteBytes sets the HTTP response body without copying it.
// From this point onward the body argument must not be changed.
func (c *Context) WriteBytes(body []byte) {
	// Write response body
	c.fiber.Send(body)
}

// WriteString sets the HTTP response body without copying it.
// From this point onward the body argument must not be changed.
func (c *Context) WriteString(body string) {
	// Write response body
	c.fiber.Send([]byte(body))
}

// SendFile transfers the file from the given path.
// The file is not compressed by default, enable this by passing a 'true' argument
// Sets the Content-Type response HTTP header field based on the filenames extension.
func (c *Context) SendFile(file string, compress ...bool) error {
	return c.fiber.SendFile(file, compress...)
}

// SendStatus sets the HTTP status code and if the response body is empty,
// it sets the correct status message in the body.
func (c *Context) SendStatus(status int) error {
	return c.fiber.SendStatus(status)
}

// SendStream sets response body stream and optional body size.
func (c *Context) SendStream(stream io.Reader, size ...int) error {
	return c.fiber.SendStream(stream, size...)
}

// WriteJSON sets the HTTP response body without copying it.
// From this point onward the body argument must not be changed.
func (c *Context) WriteJSON(body interface{}) {
	// Write response body
	var b, err = json.Marshal(body)
	if err != nil {
		c.fiber.Status(400)
		c.fiber.WriteString(err.Error())
	} else {
		c.fiber.Write(b)
	}
}

func (ctx *Context) WriteResponse(data Response) {
	ctx.WriteJSON(data)
}

func (ctx *Context) Write(data interface{}) {
	switch w := data.(type) {
	case []byte:
		ctx.fiber.Write(w)
	case string:
		ctx.fiber.Write([]byte(w))
	case int, int64, int8, int32, int16, uint, uint64, uint8, uint16, uint32, float32, float64, complex64, complex128:
		ctx.fiber.WriteString(fmt.Sprint(w))
	case error:
		ctx.fiber.Status(400)
		ctx.fiber.WriteString(w.Error())
	default:
		var b, err = json.Marshal(w)
		if err != nil {
			ctx.fiber.Status(400)
			ctx.fiber.WriteString(err.Error())
		} else {
			ctx.fiber.Write(b)
		}
	}
}

func (ctx *Context) Fiber() *fiber.Ctx {
	return ctx.fiber
}
